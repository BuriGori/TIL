# 2449번 전구

> 문제

https://www.acmicpc.net/problem/2449

> 조건

K가지의 서로 다른 색을 표현할 수 있는 전구들이 있다. 전구의 개수(1<=N<=200)와 전구의 색 종류(1<=K<=20)가 주어지고 N개의 숫자들로 현재 전구들의 색을 알려주었을 때, 모든 전구가 같은 색을 표현하는 경우를 구해야한다. (전구의 색을 바꾸면 양 옆의 전구의 색이 같고 연결된 전구는 같이 색이 바뀐다. 즉, 가운데 색이 양옆의 색들에게 전파가 된다.)  
이때 최소 몇 번 전구의 색을 바꾸어야 하는가?

> 접근법

문제의 내용에서 경우의 수를 구해야한다는 이야기가 나왔기 때문에 **DP**를 떠올려야 한다. 이때 DP를 범위를 비교하는 2차원 배열로 만들어서 주어진 범위에서 **하향식**으로 전개하여 최소가 되는 횟수를 찾아야한다.

> 코드

 ``` c++
#include<bits/stdc++.h>

using namespace std;
//최대 전구의 범위를 배열로 정의
int dp[333][333];
vector<int> vec;

int CC(int st, int ed) {
    //탈출 조건 1) 범위가 1이라면 탈출
	if (st == ed)return 0;
    //탈출 조건 2) 이미 값이 있으면 리턴
	if (dp[st][ed] != -1)return dp[st][ed];
    //최솟값을 위한 초깃값 설정
	int ret = INT_MAX;
	int l, r;
	for (int i = st; i < ed; i++) {
        //범위를 i를 기준으로 양옆으로 나눈다.
		l = CC(st, i);
		r = CC(i + 1, ed);

        //현재의 시작지점과 i+1부분의 색이 같다면 양옆으로 나눈 범위만 확인하면 된다.
		//다르다면 전구의 색을 바꾸어 주어야 하므로 +1을 해준다.
        if (vec[st] == vec[i + 1]) {
			ret = min(ret, l + r);
		}
		else
			ret = min(ret, l + r + 1);
	}
	return dp[st][ed] = ret;
}


int main() {
	memset(dp, -1, sizeof(dp));
	int n, m; cin >> n >> m;
	vec.resize(n);
	for (int i = 0; i < n; i++)
		cin >> vec[i];
	CC(0, n - 1);
	cout << dp[0][n - 1];
}
```

> 배운 점

DP에서 처음 전개를 하기위한 배열의 공간을 정하는 것과 배열의 idx를 의미있게 사용하는 범이 참 매력적인 것 같다. 전구와 같은 문제를 완전탐색으로 풀 수도 있겠지만, DP의 **메모라이제이션**을 활용하여 빠르게 정확한 답을 구하는 습관을 가져야겠다.